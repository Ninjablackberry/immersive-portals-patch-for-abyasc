package com.jkdr.abyssalascentdimensionpatcher.eventHooks;

import com.jkdr.abyssalascentdimensionpatcher.AbyssalAscentDimensionPatcher;
import com.jkdr.abyssalascentdimensionpatcher.data.SpawnPosData;
import com.jkdr.abyssalascentdimensionpatcher.mixins.MixinPlayerRespawnLogic;
import com.jkdr.abyssalascentdimensionpatcher.util.ModInternalConfig;
import com.jkdr.abyssalascentdimensionpatcher.util.PatchouliBookManager;
import com.jkdr.abyssalascentdimensionpatcher.util.ServerMessages;
import com.jkdr.abyssalascentdimensionpatcher.util.StructureSpawning;
import net.minecraftforge.event.entity.player.PlayerEvent.PlayerRespawnEvent;
import com.mojang.datafixers.util.Pair;
import com.mojang.logging.LogUtils;
import net.minecraft.advancements.Advancement;
import net.minecraft.advancements.AdvancementProgress;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Holder;
import net.minecraft.core.registries.Registries;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.level.PlayerRespawnLogic;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.util.RandomSource;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.ChunkPos;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.biome.Biome;
import net.minecraft.world.level.biome.BiomeSource;
import net.minecraft.world.level.biome.Climate;
import net.minecraft.world.level.chunk.ChunkGenerator;
import net.minecraft.world.level.levelgen.RandomState;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import com.google.common.collect.ImmutableSet;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraft.world.level.block.Block;
import org.slf4j.Logger;

import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import java.util.function.Predicate;

@Mod.EventBusSubscriber(modid = AbyssalAscentDimensionPatcher.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class playerSpawnEvents {
    private static final Logger LOGGER = LogUtils.getLogger();

    private static final Set<Block> VALID_GROUND_BLOCKS = ImmutableSet.of(
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "deepturf_block")),
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "sediment")),
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "ashen_deepturf_block")),
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "frozen_deepturf_block")),
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "depthrock")),
        ForgeRegistries.BLOCKS.getValue(new ResourceLocation("undergarden", "shiverstone"))
    ).stream().filter(Objects::nonNull).collect(ImmutableSet.toImmutableSet());

    //Just a lush area and a nice place to start
    private static final ResourceKey<Biome> FORCESPAWNINBIOME = ResourceKey.create(
        Registries.BIOME, new ResourceLocation("undergarden", "gronglegrowth")
    );

    @SubscribeEvent
    public static void onPlayerFirstJoin(PlayerEvent.PlayerLoggedInEvent event) {
        ServerPlayer player = (ServerPlayer) event.getEntity();
        CompoundTag persistent = player.getPersistentData().getCompound(Player.PERSISTED_NBT_TAG);

        MinecraftServer server = player.getServer();
        if (server == null) return;
         ServerLevel undergardenLevel = server.getLevel(ModInternalConfig.playerSpawnDimension);
        spawnStructure(player, undergardenLevel);

        if (persistent.getBoolean(ModInternalConfig.FIRST_JOIN_TAG)) {
            // Player has joined before with this mod logic, do nothing.
            return;
        }
        persistent.putBoolean(ModInternalConfig.FIRST_JOIN_TAG, true);
        player.getPersistentData().put(Player.PERSISTED_NBT_TAG, persistent);

        // Send welcome message regardless of spawn location
        ServerMessages.welcome(player);

       

        // Don't teleport players who already have a bed spawn or have already been handled before
        if (player.getRespawnPosition() != null) {
            return;
        }

        PatchouliBookManager.givePlayerPatchouliBook(player);

        // We ONLY teleport the player if they have never entered the nether before
        ResourceLocation netherAdvancementRL = new ResourceLocation("minecraft", "nether/root");
        Advancement netherAdvancement = player.getServer().getAdvancements().getAdvancement(netherAdvancementRL);
        if (netherAdvancement == null) return; // Should not happen
        AdvancementProgress advancementProgress = player.getAdvancements().getOrStartProgress(netherAdvancement);


        if (undergardenLevel == null) {
            LOGGER.error("The Undergarden dimension was not found! Ca {nnot set spawn. Is The Undergarden mod installed?");
            return;
        }

        // Teleport the player to the Undergarden's spawn point.
        BlockPos rawPos = getSpawnCoordinates(undergardenLevel);
        BlockPos adjustedPos = new BlockPos(
            rawPos.getX() - 5,
            rawPos.getY() + 1,
            rawPos.getZ() + 3
        );

        if (player.level().dimension() == Level.OVERWORLD || advancementProgress.isDone()) {
            player.teleportTo(
                undergardenLevel, 
                adjustedPos.getX() + 0.5, 
                adjustedPos.getY(), 
                adjustedPos.getZ() + 0.5, 
                player.getYRot(), 
                player.getXRot()
            );
        }
        // Setting the "forced" parameter to false ensures the spawnpoint does not get override a bed (the 4th argument)
        player.setRespawnPosition(ModInternalConfig.playerSpawnDimension, adjustedPos, 0, false, false);
    }

    @SubscribeEvent
    public static void onPlayerRespawn(PlayerRespawnEvent event) {
        if (event.isEndConquered()) return; // Don't interfere with end credits
        
        ServerPlayer player = (ServerPlayer) event.getEntity();

        // Always give a book on respawn if they are supposed to have one
        PatchouliBookManager.givePlayerPatchouliBook(player);
        
        // If the player has a bed spawn, Minecraft handles it.
        if (player.getRespawnPosition() != null) {
            return;
        }

        // Don't teleport players who already have a bed spawn or have already been handled before
        if (player.getRespawnPosition() != null || player.level().dimension() != Level.OVERWORLD) {
            return;
        }
        
        MinecraftServer server = player.getServer();
        if (server == null) return;

        ServerLevel undergardenLevel = server.getLevel(ModInternalConfig.playerSpawnDimension);
        if (undergardenLevel == null) {
            LOGGER.error("The Undergarden dimension was not found! Cannot handle respawn.");
            return;
        }

        //Dont call if player is already in the undergarden
        if (player.level() == undergardenLevel) {
            return;
        }

        BlockPos rawPos = getSpawnCoordinates(undergardenLevel);
        BlockPos adjustedPos = new BlockPos(
            rawPos.getX() - 5,
            rawPos.getY() + 1,
            rawPos.getZ() + 3
        );

        // Manually set the player's position on respawn
        player.teleportTo(
            undergardenLevel, 
            adjustedPos.getX() + 0.5, 
            adjustedPos.getY(), 
            adjustedPos.getZ() + 0.5, 
            player.getYRot(), 
            player.getXRot()
        );
    }

    public static BlockPos getSpawnCoordinates(ServerLevel level) {
        SpawnPosData spawnData = SpawnPosData.get(level);
        BlockPos customSpawnPos = spawnData.getSpawnPos();

        if (customSpawnPos == null) {
            

            //Create new spawnpoint if it couldnt be found.
            BlockPos bedCompatibleSpawn = level.getSharedSpawnPos();
            
            Predicate<Holder<Biome>> biomePredicate = (biomeHolder) -> biomeHolder.is(FORCESPAWNINBIOME);
            BiomeSource biomeSource = level.getChunkSource().getGenerator().getBiomeSource();
            RandomState randomState = level.getChunkSource().randomState();

            Climate.Sampler sampler = randomState.sampler();
            RandomSource random = level.getRandom();
            int searchRadiusInQuarts = 3200 / 4;

            // Search for the closest biome using the correct method on the BiomeSource.
            Pair<BlockPos, Holder<Biome>> biomeResult = biomeSource.findBiomeHorizontal(
                bedCompatibleSpawn.getX() / 4,
                bedCompatibleSpawn.getY(),
                bedCompatibleSpawn.getZ() / 4,
                searchRadiusInQuarts,
                biomePredicate,
                random, // The required RandomSource
                sampler // The required Climate.Sampler
             );

            if (biomeResult != null) {
                bedCompatibleSpawn = biomeResult.getFirst();
            }

            BlockPos finalSpawnPos = findSafeSpotNearby(level, bedCompatibleSpawn, 16);
            spawnData.setSpawnPos(bedCompatibleSpawn);

            return bedCompatibleSpawn; 
        }

        return customSpawnPos;
    }

    private static void spawnStructure(ServerPlayer player, ServerLevel level) {
        SpawnPosData spawnData = SpawnPosData.get(level);
        BlockPos customSpawnPos = spawnData.getSpawnPos();
        if (customSpawnPos != null) {
            return;
        }
        LOGGER.info("Building spawn structure, didnt exist before");

        BlockPos spawnBlockData = getSpawnCoordinates(level);

        BlockPos offsetStructure = new BlockPos(
            spawnBlockData.getX() - 7,
            spawnBlockData.getY() - 4,
            spawnBlockData.getZ() -1 
        );

        LOGGER.info("{}", offsetStructure);

        StructureSpawning.createSpawnStructure(level, offsetStructure);
    }

    private static boolean isSpawnValid(ServerLevel level, BlockPos pos) {
        if (pos == null) {
            return false;
        }
        
        // 1. Get the block the player will be standing ON.
        Block groundBlock = level.getBlockState(pos.below()).getBlock();

        // 2. Perform all three checks in one return statement.
        return VALID_GROUND_BLOCKS.contains(groundBlock) &&      // Is the ground valid?
               level.getBlockState(pos).isAir() &&               // Is the feet space air?
               level.getBlockState(pos.above()).isAir();         // Is the head space air?
    }

    public static BlockPos findSafeSpotNearby(ServerLevel level, BlockPos initialPos, int searchRadius) {
        if (isSpawnValid(level, initialPos)) {
            return initialPos;
        }

        // If not, start searching in an expanding box around the initial point.
        // We use the SafeSpawnFinder's top-down scan on each column in the search area.
        for (int xOffset = -searchRadius* 16; xOffset <= searchRadius; xOffset += 16) {
            for (int zOffset = -searchRadius* 16; zOffset <= searchRadius; zOffset += 16) {

                if (xOffset == 0 && zOffset == 0) continue;

                BlockPos searchColumn = initialPos.offset(xOffset, 0, zOffset);

                ChunkPos targetChunk = new ChunkPos(searchColumn);
                level.getChunk(targetChunk.x, targetChunk.z);

                // Use the reliable top-down scan for this new column
                BlockPos potentialSpot = findSafeSpawnablePos(level, PlayerRespawnLogic.getSpawnPosInChunk(level, new ChunkPos(searchColumn)));

                if (isSpawnValid(level, potentialSpot)) {
                    // We found a valid spot in a nearby chunk/column!
                    return potentialSpot;
                }
            }
        }

        // If the entire search fails, return null.
        return null;
    }

    public static BlockPos findSafeSpawnablePos(ServerLevel level, BlockPos targetPos) {
        if (targetPos == null) {
            return null; // Prevent crashes if a null position is passed in
        }

        int x = targetPos.getX();
        int z = targetPos.getZ();

        // Start from the logical top of the world and scan downwards.
        for (int y = level.getLogicalHeight(); y > level.getMinBuildHeight(); y--) {
            BlockPos currentPos = new BlockPos(x, y, z);
            
            // Check if the block *below* the current position is solid (i.e., it's ground)
            if (!level.getBlockState(currentPos.below()).isAir()) {
                BlockPos headPos = currentPos.above(); // Player's head will be here.

                // Check if the spot for the feet AND the head are both air.
                if (level.getBlockState(currentPos).isAir() && level.getBlockState(headPos).isAir()) {
                    // This is a safe spot! Return the position for the player's feet.
                    return currentPos; 
                }
            }
        }
        // If the loop finishes without finding a spot, return null.
        return null; 
    }
}
